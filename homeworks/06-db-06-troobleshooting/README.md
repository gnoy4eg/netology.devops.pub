# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB  

Ответ:  
Можно сделать запрос используя db.currentOp()
```sql
db.currentOp(
   {
     "active" : true,
     "secs_running" : { "$gt" : 180 },
     "ns" : /^db1\./
   }
)
```
Затем, прибить операцию по идентификатору (opid), найденному в прошлым запросом:
```sql
db.killOp("shardA:100813");
```

Для решения проблем с производительностью следует сделать\проверить:
-  постороить\перестроить соответствующий индекс
-  Проверить количество подключений к БД (возможно, упираемся в лимиты)
-  проверить свободное место на диске

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?  

Ответ:  
Проблема в отсутствии свободной памяти на сервере. Скорость роста числа записываемых значений выше, чем скорость роста числа
выбывающих значений, в определенный момент объём хранимых значений, которые ещё не истекли, превышает объём
доступной памяти, операции malloc() блокирутся и записать больше данных в БД невозможно, пока часть памяти
не освободится.  
Нужно увеличить значение параметра maxmemory в конфиге Redis, либо разрешить использование виртуальной
памяти (однако это снизит быстродействие сервера).  
Так же можно использовать одну из политик,
срабатывающих после достижения лимита доступной памяти:  
volatile-lru - удалять ключи с TTL, которые редко используются  
volatile-ttl - удалять ключи с TTL, которые скоро истекут  
volatile-random - удалять ключи с TTL в случайном порядке  
allkeys-lru - удалять ключи с TTL и без TTL, которые редко используются  
allkeys-random - удалять с TTL и без TTL в случайном порядке  

 
## Задача 3

Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?  

Ответ:  
Скорее всего данная ошибка стала возникать из-за возросшей нагрузки на сервер с БД.  
Пути решения:
- попробовать создать индексы для оптимизации и ускорения запросов
- так же может помочь увеличение значений у параметров: connect_timeout, interactive_timeout, wait_timeout
- можно добавить ресурсов на сервере...
- не забыть проверить сетевой стек, увеличить значение параметроа net_read_timeout и увеличить максимальное количество соединений (параметр: max_connections)


## Задача 4

Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?  

Ответ:  
Причина кроется в закончившейся оперативной памяти, механизм Out-Of-Memory Killer завершает процесс postmaster, что бы не "упала" вся ОС.  
Вижу несколько вариантов решения проблемы:
- добавить оперативной памяти на хост с БД
- разрешить\увеличить swap (снизится быстродействие)
- оптимизировать ресурсоемкие запросы к БД
- провести шардирование таблиц

### Доработка ДЗ  
Задача 4  
Дополнительно почитал статью на [Хабре](https://habr.com/ru/company/southbridge/blog/464245/) по OOMKiller'у.  
Тогда вижу несколько вариантов решения проблемы.  
- Радикальный:  
Отключить OOMKiller (не рекомендуется). Заработает сразу в т.ч. после перезагрузки
```bash
sudo -s sysctl -w vm.oom-kill = 0
sudo echo vm.oom-kill = 0 >>/etc/sysctl.conf
 ```
- Опасный:  
Передать отрицательное значение для параметра ядра oom_score_adj. Чем более отрицательное значение, тем ниже шансы на завершение процесса OOMKiller'ом
```sql
postgres=# SELECT pg_backend_pid();
pg_backend_pid 
----------------
    3813
(1 row)
```
```bash
sudo echo -100 > /proc/3813/oom_score_adj
```
- Рекомендуемый (безопасный):  
Передать параметру vm.overcommit_memory значение 2
```bash
echo 2 > /proc/sys/vm/overcommit_memory
```

Я бы выбрал последний вариант (рекомендуемый\безопасный)